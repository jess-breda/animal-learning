import pandas as pd
import numpy as np
from collections import Counter


class NullModel:
    def __init__(self, test_sessions, mode="multi"):
        """
        Class to fit a null model to the data. This model will
        calculate the observed probabilities for each choice label
        and return the negative log-likelihood of the observed
        probabilities and counts.

        params
        ------
        test_sessions : list
            list of sessions for the test set computed by the
            design matrix generator
        mode : str (default="multi")
            whether to use binary (L,R) or multi-class (L, R, V) for the
            null model.
        """
        self.test_sessions = test_sessions
        self.mode = mode
        self.label_map = {0: "L", 1: "R", 2: "V"}

    def fit(self, animal_df):
        """
        Function to fit a null model to the data. This model will
        calculate the observed probabilities for each choice label
        and return the negative log-likelihood of the observed
        probabilities and counts.

        params
        ------
        animal_df : pd.DataFrame
            dataframe with columns `choice` and `session` for a single
            animal. Likely generated by get_rat_viol_data() and filtered.
            NOTE: this is not the design matrix!

        returns
        -------
        null_model_info : dict
            dictionary with keys `nll`, `n_test_trials`, `n_train_trials`,
            `p_L`, `p_R`, `p_V`, `n_L`, `n_R`, `n_V`
        """

        assert animal_df.animal_id.nunique() == 1, "Multiple animals being fit!!"
        self.animal_id = animal_df.animal_id.unique()[0]

        if self.mode == "binary":
            # Drop NaNs for binary mode
            df = animal_df.dropna(subset=["choice"])
            choice = df.choice
        elif self.mode == "multi":
            # Fill NaNs with 2 for multi mode
            df = animal_df.copy()
            choice = df.choice.fillna(2)

        # Get test labels (0:L, 1:R, 2:V) & count occurences
        test_labels = choice[df["session"].isin(self.test_sessions).values]
        label_counts = Counter(test_labels)
        total_count = len(test_labels)

        # Calculate observed probabilities
        probabilities = {
            label: count / total_count for label, count in label_counts.items()
        }

        # Calculate the log-likelihood based on the observed counts & probabilities
        log_likelihood = 0
        for label, prob in probabilities.items():
            log_likelihood += label_counts[label] * np.log(prob)

        null_model_info = {
            "nll": -log_likelihood,
            "n_test_trials": total_count,
            "n_train_trials": len(animal_df) - total_count,
        }

        for label, label_str in self.label_map.items():
            null_model_info[f"p_{label_str}"] = probabilities.get(label, 0)
            null_model_info[f"n_{label_str}"] = label_counts.get(label, 0)

        return null_model_info

    def compute_and_store(self, animal_df):
        """
        Function to compute and store the null model information for
        a single animal. Collected information includes the negative
        log-likelihood, the number of test and train trials and the
        observed probabilities for each choice label.

        params
        ------
        animal_df : pd.DataFrame
            dataframe with columns `choice` and `session` for a single
            animal. Likely generated by get_rat_viol_data() and filtered.
            NOTE: this is not the design matrix!

        returns
        -------
        null_info_df : pd.DataFrame
            dataframe with columns `animal_id`, `model_name`, `nll`,
            `n_test_trials`, `n_train_trials`, `p_L`, `p_R`, `p_V`,
            `n_L`, `n_R`, `n_V`
        """
        null_model = self.fit(animal_df)

        null_info_df = pd.DataFrame(
            {
                "animal_id": [self.animal_id],
                "model_name": ["null"],
                "model_type": self.mode,
                **null_model,
            }
        )

        return null_info_df
