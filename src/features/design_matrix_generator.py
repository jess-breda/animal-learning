"""
Parent class for generating design matrices for different models.
Written by Jess Breda, 2023-10-23
"""

import pandas as pd
import numpy as np
from exp_filter import ExpFilter


class DesignMatrixGenerator:
    def __init__(self, verbose=False):
        self.verbose = verbose
        pass

    @staticmethod
    def normalize_column(col):
        return (col - col.mean()) / col.std()

    @staticmethod
    def one_hot_encode_labels(df):
        """
        Function to one-hot encode choice labels for each trial. In
        the case of the rat data, this is a 3-dimensional vector
        left, right or violation (C = 3). Note this function is
        flexible to the number of choice options (C).

        params
        ------
        df : pd.DataFrame
            dataframe with columns `choice` likely generated by
            get_rat_viol_data()

        returns
        -------
        Y : np.ndarray, shape (N, C), where typically C = 3
            one-hot encoded choice labels for each trial as left,
            right or violation: [[1 0 0] , [0 1 0], [0 0 1]]
        """

        Y = pd.get_dummies(df["choice"], "choice", dummy_na=True).to_numpy(copy=True)
        return Y

    @staticmethod
    def encode_binary_lr_labels(df):
        """
        Function to encode choice labels for each trial as binary
        left or right (C = 2) and drop data for violation trials

        params
        ------
        df : pd.DataFrame
            dataframe with columns `choice` likely generated by
            get_rat_viol_data() or get_rat_data()

        returns
        -------
        y : np.ndarray, shape (N, 1)
            binary encoded labels with 0 for left and 1 for right
        """

        y = df["choice"].dropna().astype(int).to_numpy()
        return y

    @staticmethod
    def exp_filter_column(X, tau, column, verbose=False):
        """
        Function to apply exponential filter to a column in a dataframe
        and drop the original column

        params
        ------
        X : pd.DataFrame
            dataframe with column to be filtered
        tau : float
            time constant for exponential filter.
        column : str
            column to apply filter to
        verbose : bool (default=False)
            whether to print out progress

        returns
        -------
        X_filtered : pd.DataFrame
            dataframe with filtered column and original column dropped

        """
        X_filtered = ExpFilter(
            tau, column=column, verbose=verbose
        ).apply_filter_to_dataframe(X)

        X_filtered.drop(columns=[column], inplace=True)

        return X_filtered

    def generate_base_matrix(self, df, model_type="multi", return_labels=True):
        """
        Function to generate "base" design matrix given a dataframe
        with violations tracked. In this case base means:
            - normalized s_a, s_b columns
            - prev_violation column (multi only)
            - prev_sound_avg column
            - prev_correct column
            - prev_choice column
            - bias column
            - session number column (for merging)

        params
        ------
        df : pd.DataFrame
            dataframe with columns `s_a` `s_b` `session`, `violation`
            `correct_side` and `choice`, likely generated by
            get_rat_viol_data() or get_rat_date()
        model_type : str (default="multi")
            model design matrix will be used for. If multi, returns
            one-hot encoded labels and has a prev_violation column.
            If binary, returns binary encoded labels w/o prev_violation
        return_labels : bool (default=True)
            whether or not to return labels with design matrix

        returns
        -------
        X : pd.DataFrame, shape (N, 8) if multi, (N, 7) if binary
            design matrix with regressors for s_a, s_b, prev_violation,
            prev sound avg, correct side, choice info, bias and session id
            (for merging). If model_type is binary then prev_violation
            column is removed
        Y : np.ndarray, shape (N, 3) if multi-class (N, ) if binary
            when return_labels=True.
        """

        # Check
        assert len(df["animal_id"].unique()) == 1, "More than 1 animal in dataframe"

        # Initialize
        X = pd.DataFrame()
        stim_cols = ["s_a", "s_b"]
        X["session"] = df.session

        # Masks- if first trial in a session and/or previous trial
        # was a violation, "prev" variables get set to 0
        self.session_boundaries_mask = df["session"].diff() == 0
        X["prev_violation"] = (
            df["violation"].shift() * self.session_boundaries_mask
        ).fillna(0)
        self.prev_violation_mask = X["prev_violation"] == 0

        # Stimuli (s_a, s_b) get normalized
        for col in stim_cols:
            X[stim_cols] = self.normalize_column(df[stim_cols])

        # Average previous stimulus (s_a, s_b) loudness
        X["prev_sound_avg"] = df[stim_cols].shift().mean(axis=1)
        X["prev_sound_avg"] = self.normalize_column(X["prev_sound_avg"])
        X["prev_sound_avg"] *= self.session_boundaries_mask * self.prev_violation_mask

        # Prev correct side (L, R) (0, 1) -> (-1, 1),
        X["prev_correct"] = (
            df.correct_side.replace({0: -1}).astype(int).shift()
            * self.session_boundaries_mask
            * self.prev_violation_mask
        )

        # prev choice regressors (L, R, V) (0, 1, Nan) -> (-1, 1, 0),
        X["prev_choice"] = (
            df.choice.replace({0: -1}).fillna(0).astype(int).shift()
            * self.session_boundaries_mask
        )

        # if binary, drop the violation trials and the prev_violation column
        if model_type == "binary":
            X = X[df["violation"] != 1].reset_index(drop=True)
            X.drop(columns=["prev_violation"], inplace=True)

        X.fillna(0, inplace=True)  # fill nans that come from shift()
        X.insert(0, "bias", 1)  # add bias column

        if return_labels:
            if model_type == "binary":
                # make choice vector, drop nans (violations) to match X
                Y = self.encode_binary_lr_labels(df)
            elif model_type == "multi":
                Y = self.one_hot_encode_labels(df)
            return X, Y
        else:
            return X
