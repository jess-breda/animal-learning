import numpy as np
import pandas as pd


def generate_base_design_matrix(df, return_labels=True):
    """
    Function to generate "base" design matrix given a dataframe
    with violations tracked. In this case "base" means using the
    same regressors as Nick Roy did in Psytrack, but adjusted to
    take into account 3 choice options (L,R, Violation).

    N = number of trials
    D = number of features
    C = number of classes, in this case 3 (L, R, Violation)

    params
    ------
    df : pd.DataFrame
        dataframe with columns `s_a` `s_b` `session`, `violation`
        `correct_side` and `choice`, likely generated by
        get_rat_viol_data()
    return_label : bool (default: True)
        whether to return one-hot encoded choice labels

    returns
    -------
    X : pd.DataFrame, shape (N, D + 1)
        design matrix with regressors for s_a, s_b and previous
        violation, sound avg, correct side and choice info,
        normalized to standard normal with bias column added
    Y : np.ndarray, shape (N, C), where C = 3
        one-hot encoded choice labels for each trial as left,
        right or violation
    """

    X = pd.DataFrame()

    # normalize sa/sb to standard normal
    X["s_a"] = (df.s_a - df.s_a.mean()) / df.s_a.std()
    X["s_b"] = (df.s_b - df.s_b.mean()) / df.s_b.std()

    # mask session boundaries to 0
    session_boundaries_mask = df["session"].diff() == 0

    # mask previous violations to 0 & create prev_violation regressors
    X["prev_violation"] = (df.violation.shift() * session_boundaries_mask).fillna(0)
    prev_violation_mask = X.prev_violation == 0

    # get average stimulus loudness from previous trial (if exists)
    # and normalize to standard normal
    # here we assume, if prev trial was violation or session boundary
    # that the sound avg is 0
    X["prev_sound_avg"] = df[["s_a", "s_b"]].shift().mean(axis=1)
    X["prev_sound_avg"] = (
        X.prev_sound_avg - X.prev_sound_avg.mean()
    ) / X.prev_sound_avg.std()
    X["prev_sound_avg"] = (
        X.prev_sound_avg * session_boundaries_mask * prev_violation_mask
    )

    # prev correct side (L, R) (0, 1) -> (-1, 1),
    # here we assume, if prev trial was violation or session boundary
    # that the correct is 0
    X["prev_correct"] = (
        df.correct_side.replace({0: -1}).astype(int).shift()
        * session_boundaries_mask
        * prev_violation_mask
    )

    # prev choice regressors (L, R) (0, 1) -> (-1, 1),
    # here we assume, if prev trial was violation (coded as nan)
    # or session boundary that the choice is 0
    X["prev_choice"] = (
        df.choice.replace({0: -1}).fillna(0).astype(int).shift()
        * session_boundaries_mask
    )

    X.fillna(0, inplace=True)  # .shifts() make trial 0 nan, remove this
    X.insert(0, "bias", 1)

    if return_labels:
        Y = one_hot_encode_labels(df)
        return X, Y
    else:
        return X


def one_hot_encode_labels(df):
    """
    Function to one-hot encode choice labels for each trial as
    left, right or violation (C = 3)

    params
    ------
    df : pd.DataFrame
        dataframe with columns `choice` likely generated by
        get_rat_viol_data()

    returns
    -------
    Y : np.ndarray, shape (N, C), where C = 3
        one-hot encoded choice labels for each trial as left,
        right or violation
    """

    Y = pd.get_dummies(df["choice"], "choice", dummy_na=True).to_numpy(copy=True)
    return Y
